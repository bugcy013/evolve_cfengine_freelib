# Copyright Evolve Thinking ( www.evolvethinking.com ).
# For fresh updates visit:
# https://github.com/evolvethinking/evolve_cfengine_freelib

#
# License
#
# Evolve_freelib.cf is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.  See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License along with
# this program.  If not, see <http://www.gnu.org/licenses/>.

#
# Introduction
#
# The bundles contained in this library primarily focus on content driven
# policy.  Each such bundle takes csv type delimited parameter file as shown in
# the common bundle efl_c. A record consists of a single line and the required
# fields.
#
# A skeleton bundle is provided for those that wish to create new bundles.

#
# Requirements
# 
# CFEngine Core 3.5.x or higher
# CFEengine standard library

bundle agent efl_skeleton ( ref )
{
   meta:
      "purpose" string => "Skeleton bundle for new bundle authoring";
      "field_0" string => "Context";

   vars:
      "dim_skel"
         comment => "Read data file for parsing.",
         handle  => "efl_skeleton_vars_files",
         int     => readstringarrayidx(
            "skel_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

		"f"
			comment => "Get index array loaded above.",
			handle  => "efl_skeleton_vars_f",
			slist   => getindices( "skel_o" );

      "f2"
         comment => "Work around for bug 2333",
         slist => { "0" };
 
      "skel[${f}][${f2}]"
         comment => "Work around for bug 2333",
         string => "${skel_o[${f}][${f2}]}";
}

bundle common efl_c
{
   meta:
      "purpose" string => "Common variables used by this library";

   vars:
      "cache"
         comment => "Location for agent to cache template and other temp files",
         string  => "/var/cache/cfengine";

      "policy_servers"
         comment => "Policy servers for remote copies",
         slist   => { "${sys.policy_hub}" };

      "class"
         comment => "Regex to extract class name from parameter file name.",
         string  => ".*?-(\w+)\.txt";

      "comment"
         comment => "Comment string in data file.",
         string  => "\s*#[^\n]*";

      "array_delimiter"
         comment => "Field delimiter for CSV data files read by readstringarrayidx",
         string  => "\s*;;\s*";

      "slist_delimiter"
         comment => "Field delimiter for CSV data files read by readstringlist",
         string  => "\s";

      "max_num"
         comment => "Maximum number of lines to read from data file",
         int     => "500";

      "max_bytes"
         comment => "Maximum number of bytes to read from data file.",
         string  => "1M";

      "logdir"
         comment => "Log dir for Delta Reporting logs",
         string => "${sys.workdir}/delta_reporting/log";

      "promise_log"
         comment => "Location for experimental promise outcome log.",
         string  => "${logdir}/promises";

      "udate"
         comment => "Date stamp to match agent output",
         string  => strftime( "localtime", "%Y-%m-%dT%H:%M:%S%z", now() );

      "efl_server_txt"
            comment => "Server access rules parameter file",
# NOTE Access file must be hardcoded because server bundles do not accept arguments.
            string => "${sys.workdir}/inputs/user_data/bundle_params/efl_server.txt";
}

bundle agent efl_main( ref )
{
   meta:
      "meta_purpose" string => "All policies are called via methods iteration from this bundle.";

      "method_field_0" string => "Context when method is called";
      "method_field_1" string => "Method promiser name";
      "method_field_2" string => "Bundle name";
      "method_field_3" string => "Ifelapsed";
      "method_field_4" string => "Bundle parameter";
      "method_field_5" string => "Promisee";

   vars:
      "dim_methods"
         comment => "Read data to be used in method promises.",
         int     => readstringarrayidx(
            "meth_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
            );

      "i" 
         comment => "Convert module list to local list for bug work-around",
         slist   => { @{return_index_pl.efl_main} };

      "i2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3", "4", "5" };
 
      "meth[${i}][${i2}]"
         comment => "Work around for bug 2333",
         string => "${meth_o[${i}][${i2}]}";

   classes:
      !use_ordered_index::
         "use_ordered_index"
            comment    => "Created ordered index for method calls",
            expression => usemodule( "return_index.pl", "efl_main ${dim_methods}" );

   methods:
      "methods loop wrapper"
         comment    => "Call wrapper bundle to workaround naked variable bug.",
         handle     => "efl_main_methods_efl_bug2638",
         ifvarclass => "${meth[${i}][0]}",
         action     => if_elapsed( "${meth[${i}][3]}" ),
         usebundle  => efl_bug2638(
            "${meth[${i}][1]}_${i}",
            "${meth[${i}][5]}",
            "${meth[${i}][2]}",
            "${meth[${i}][4]}"
         );
}

bundle agent efl_bug2638(promiser_name, promisee_name, bundle_name, parameter)
{
   meta:
      "meta_purpose" string => "Workaround for naked variable bug 2638.";
      "bug"          string => "https://cfengine.com/dev/issues/2638";

   methods:
      "${promiser_name}" -> { "${promisee_name}" }
         comment    => "Methods promises described in methods.txt",
         handle     => "efl_bug2638_methods_loop",
         usebundle  => ${bundle_name}( "${parameter}" );
}

bundle agent efl_sysctl_live( ref )
{   
   meta:
      "purpose" string => "Promise live sysctl kernel settings";
      "field_0" string => "Context";
      "field_1" string => "sysctl variable";
      "field_2" string => "sysctl value";
      "field_3" string => "Promisee";

   vars:
      "dim_sysctl"
         comment => "Read data file for parsing.",
         handle  => "efl_sysctl_live_vars_sysctl_promiser",
         int     => readstringarrayidx(
            "sysctl_promiser_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

		"x"
			comment => "Get index array loaded above.",
			handle  => "efl_sysctl_live_vars_x",
			slist   => getindices( "sysctl_promiser_o" );

      "x2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3" };
      
      "sysctl_promiser[${x}][${x2}]"
         comment => "Work around for bug 2333",
         string => "${sysctl_promiser_o[${x}][${x2}]}";

      "efl_sysctl_live[${sysctl_promiser[${x}][1]}]"
         comment    => "Set current live value",
         ifvarclass => "${sysctl_promiser[${x}][0]}",
         string     => execresult(
            "${paths.path[sysctl]} -n ${sysctl_promiser[${x}][1]} |${paths.path[tr]} '[:space:]' ' ' ",
            "useshell"
         );

   classes:
# TODO need to set promises differently here?
		"set_live_sysctl_${sysctl_promiser[${x}][1]}"
			comment    => "Set class if live sysctl variable not equal to promised value",
			ifvarclass => "${sysctl_promiser[${x}][0]}",
			not        => strcmp( "${sysctl_promiser[${x}][2]}", "${efl_sysctl_live[${sysctl_promiser[${x}][1]}]}" );

		"${sysctl_promiser[${x}][1]}=${sysctl_promiser[${x}][2]}_handle_efl_sysctl_live_classes_ok_kept"
			comment    => "Set class if live sysctl variable not equal to promised value",
			handle     => "efl_sysctl_live_classes_ok",
			scope      => "namespace",
			ifvarclass => "${sysctl_promiser[${x}][0]}",
			expression => strcmp( "${sysctl_promiser[${x}][2]}", "${efl_sysctl_live[${sysctl_promiser[${x}][1]}]}" );

   commands:
      "${paths.path[sysctl]} -w ${sysctl_promiser[${x}][1]}='${sysctl_promiser[${x}][2]}'" -> { "${sysctl_promiser[${x}][3]}" }
         comment    => "Set live sysctl variable",
         handle     => "efl_sysctl_live_commands_sysctl_w",
			classes    => efl_rkn( "${paths.path[sysctl]} -w ${sysctl_promiser[${x}][1]}='${sysctl_promiser[${x}][2]}'", "efl_sysctl_live_commands_sysctl_w" ),
			action     => efl_delta_reporting( "efl_sysctl_live_commands_sysctl_w", "${paths.path[sysctl]} -w ${sysctl_promiser[${x}][1]}='${sysctl_promiser[${x}][2]}'", "${sysctl_promiser[${x}][3]}", "1" ),
         ifvarclass => canonify( "set_live_sysctl_${sysctl_promiser[${x}][1]}" ),
         contain    => in_shell_and_silent;

   reports:
      delta_reporting::
         "efl_sysctl_live_classes_ok ;; ${sysctl_promiser[${x}][1]}=${sysctl_promiser[${x}][2]} ;; ${sysctl_promiser[${x}][3]}" -> { "${sysctl_promiser[${x}][3]}" }
            handle         => "efl_sysctl_live_reports_log_promises",
            ifvarclass     => canonify( "${sysctl_promiser[${x}][1]}=${sysctl_promiser[${x}][2]}_handle_efl_sysctl_live_classes_ok_kept" ),
            report_to_file => "${efl_c.promise_log}";
}

bundle agent efl_sysctl_conf_file( ref )
{
   meta:
      "purpose" string => "Promise live sysctl.conf.";
      "field_0" string => "Context";
      "field_1" string => "sysctl variable";
      "field_2" string => "sysctl value";
      "field_3" string => "Promisee";

   vars:
      "sysctl_conf"  string => "/etc/sysctl.conf";

      "dim_sysctl"
         comment => "Read data file for parsing.",
         handle  => "efl_sysctl_conf_file_vars_sysctl",
         int     => readstringarrayidx(
            "sysctl_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

		"x"
			comment => "Get index array loaded above.",
			handle  => "efl_sysctl_conf_file_vars_x",
			slist   => getindices( "sysctl_o" );

      "x2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3" };
      
      "sysctl[${x}][${x2}]"
         comment => "Work around for bug 2333",
         string => "${sysctl_o[${x}][${x2}]}";

   files:
      "${sysctl_conf}" -> { "Provisioning" }
         comment       => "Promise whole contents of sysctl.conf",
         handle        => "efl_sysctl_conf_file_files_contents",
			classes       => efl_rkn( "${sysctl_conf}", "efl_sysctl_conf_file_files_contents" ),
			action        => efl_delta_reporting( "efl_sysctl_conf_file_files_contents", "${sysctl_conf}", "Harending", "1" ),
         create        => "true",
         edit_defaults => empty,
         edit_line     => el_efl_sysctl_conf_file( "efl_sysctl_conf_file.sysctl" );

      "${sysctl_conf}" -> { "Provisioning" }
         handle  => "efl_sysctl_conf_file_files_perms",
			classes => efl_rkn( "${sysctl_conf}", "efl_sysctl_conf_file_files_perms" ),
			action  => efl_delta_reporting( "efl_sysctl_conf_file_files_perms", "${sysctl_conf}", "Harending", "1" ),
         perms   => mog( "644", "root", "root" );
}

bundle edit_line el_efl_sysctl_conf_file( ref )
{   
   vars:
      "x"
         comment => "Get index array loaded above.",
         handle  => "el_efl_sysctl_conf_file_vars_x",
         slist   => getindices( "${ref}" );

   insert_lines:
      "${${ref}[${x}][1]} = ${${ref}[${x}][2]}" -> { "${${ref}[${x}][3]}" }
         handle     => "el_efl_sysctl_conf_file_insert_lines",
# TODO classes and actions do not seem to work in this bundle type.
			classes    => efl_rkn( "${${ref}[${x}][1]} = ${${ref}[${x}][2]}", "el_efl_sysctl_conf_file_insert_lines" ),
			action     => efl_delta_reporting( "el_efl_sysctl_conf_file_insert_lines", "${${ref}[${x}][1]} = ${${ref}[${x}][2]}", "${${ref}[${x}][3]}", "1" ),
         ifvarclass => "${${ref}[${x}][0]}";
}

bundle agent efl_command ( ref )
{
   meta:
      "purpose" string => "Run given command if context is true.";
      "field_0" string => "Context";
      "field_1" string => "Command";
      "field_2" string => "usehell";
      "field_3" string => "module";
      "field_4" string => "ifelapsed";
      "field_5" string => "promisee";

   vars:
      "dim_cmd"
         comment => "Read data file for parsing.",
         handle  => "efl_command_vars_files",
         int     => readstringarrayidx(
            "cmd_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

		"c"
			comment => "Get index array loaded above.",
			handle  => "efl_command_vars_c",
			slist   => getindices( "cmd_o" );

      "c2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3", "4", "5" };

      "cmd[${c}][${c2}]"
         comment => "Work around for bug 2333",
         string => "${cmd_o[${c}][${c2}]}";

   commands:
      "${cmd[${c}][1]}" -> { "${cmd[${c}][5]}" }
         comment    => "Run desired command",
			handle => "efl_command_commands",
         ifvarclass => "${cmd[${c}][0]}",
         contain    => contain_efl_command( "${cmd[${c}][2]}" ),
         module     => "${cmd[${c}][3]}",
			classes    => efl_rkn( "${cmd[${c}][1]}", "efl_command_commands" ),
			action     => efl_delta_reporting( "efl_command_commands", "${cmd[${c}][1]}", "${cmd[${c}][5]}", "${cmd[${c}][4]}" );
}

body contain contain_efl_command ( useshell )
{
   useshell => "${useshell}";
}

bundle agent efl_link ( ref )
{
   meta:
      "purpose" string => "Link files if context is true.";
      "field_0" string => "Context";
      "field_1" string => "File promiser";
      "field_2" string => "Link source";
      "field_3" string => "Link type";
      "field_4" string => "Promisee";

   vars:
      "dim_link"
         comment => "Read data file for parsing.",
         handle  => "efl_link_vars_files",
         int     => readstringarrayidx(
            "link_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

		"l"
			comment => "Get index array loaded above.",
			handle  => "efl_link_vars_f",
			slist   => getindices( "link_o" );

      "l2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3", "4" };

      "link[${l}][${l2}]"
         comment => "Work around for bug 2333",
         string => "link_o[${l}][${l2}]";

   files:
      "${link[${l}][1]}" -> { "${link[${l}][4]}" }
         comment    => "Make link if class is true",
         handle     => "efl_link_files_target",
         ifvarclass => "${link[${l}][0]}",
			classes    => efl_rkn( "${link[${l}][1]}", "efl_link_files_target" ),
			action     => efl_delta_reporting( "efl_link_files_target", "${link[${l}][1]}", "${link[${l}][4]}", "1" ),
         link_from  => efl_source_type( "${link[${l}][2]}", "${link[${l}][3]}" );
}

body link_from efl_source_type ( source, type )
{
   source         => "${source}";
   link_type      => "${type}";
   when_no_source => "force";
}

bundle agent efl_delete_files ( ref )
{
   meta:
      "purpose" string => "Delete files that match the given criteria.";
      "field_0" string => "Context";
      "field_1" string => "Files promiser";
      "field_2" string => "Recurse no/#/inf";
      "field_3" string => "Leaf regex";
      "field_4" string => "Negative match yes/no";
      "field_5" string => "File age in days";
      "field_6" string => "Promisee";

   vars:
      "dim_files"
         comment => "Read data file for parsing.",
         handle  => "efl_delete_files_vars_files",
         int     => readstringarrayidx(
            "files_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

		"f"
			comment => "Get index array loaded above.",
			handle  => "efl_delete_files_vars_f",
			slist   => getindices( "files_o" );

      "f2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3", "4", "5", "6" };

      "files[${f}][${f2}]"
         comment => "Work around for bug 2333",
         string => "${files_o[${f}][${f2}]}";

   classes:
         "${files[${f}][1]}_isdir_${f}" -> { "${files[${f}][6]}" }
            comment    => "Determine if promiser is a directory",
            ifvarclass => "${files[${f}][0]}",
            expression => isdir( "${files[${f}][1]}" );

         "${files[${f}][1]}_negative_match_${f}" -> { "${files[${f}][6]}" }
            comment    => "Determine if negated match is desired.",
            ifvarclass => "${files[${f}][0]}",
            expression => strcmp( "yes", "${files[${f}][4]}" );

   files:
      "${files[${f}][1]}" -> { "${files[${f}][6]}" }
         comment      => "Delete files recursively",
         handle       => "efl_delete_files_files_isdir",
			classes      => efl_rkn( "${files[${f}][1]}", "efl_delete_files_files_isdir" ),
			action       => efl_delta_reporting( "efl_delete_files_files_isdir", "${files[${f}][1]}", "${files[${f}][6]}", "1" ),
         ifvarclass   => and(
            canonify( "${files[${f}][1]}_isdir_${f}" ),
            not( canonify( "${files[${f}][1]}_negative_match_${f}" ))),
         depth_search => recurse( "${files[${f}][2]}" ),
         file_select  => name_age( "${files[${f}][3]}", "${files[${f}][5]}" ),
         delete       => tidy;

      "${files[${f}][1]}" -> { "${files[${f}][6]}" }
         comment      => "Delete files",
         handle       => "efl_delete_files_files_single",
			classes      => efl_rkn( "${files[${f}][1]}", "efl_delete_files_files_single" ),
			action       => efl_delta_reporting( "efl_delete_files_files_single", "${files[${f}][1]}", "${files[${f}][6]}", "1" ),
         ifvarclass   => and(
            canonify( "${files[${f}][0]}" ),
            not( canonify( "${files[${f}][1]}_isdir_${f}" )),
            not( canonify( "${files[${f}][1]}_negative_match_${f}" ))),
         file_select  => name_age( "${files[${f}][3]}", "${files[${f}][5]}" ),
         delete       => tidy;

      "${files[${f}][1]}" -> { "${files[${f}][6]}" }
         comment      => "Delete files recursively excluding leaf name.",
         handle       => "efl_delete_files_files_isdir_negative",
			classes      => efl_rkn( "${files[${f}][1]}", "efl_delete_files_files_isdir_negative" ),
			action       => efl_delta_reporting( "efl_delete_files_files_isdir_negative", "${files[${f}][1]}", "${files[${f}][6]}", "1" ),
         ifvarclass   => and(
            canonify( "${files[${f}][1]}_isdir_${f}" ),
            canonify( "${files[${f}][1]}_negative_match_${f}" )),
         depth_search => recurse( "${files[${f}][2]}" ),
         file_select  => name_age_negate( "${files[${f}][3]}", "${files[${f}][5]}" ),
         delete       => tidy;

      "${files[${f}][1]}" -> { "${files[${f}][6]}" }
         comment      => "Delete files, excluding leaf name",
         handle       => "efl_delete_files_files_single_negative",
			classes      => efl_rkn( "${files[${f}][1]}", "efl_delete_files_files_single_negative" ),
			action       => efl_delta_reporting( "efl_delete_files_files_single_negative", "${files[${f}][1]}", "${files[${f}][6]}", "1" ),
         ifvarclass   => and(
            not( canonify( "${files[${f}][1]}_isdir_${f}" )),
            canonify( "${files[${f}][1]}_negative_match_${f}" )),
         file_select  => name_age_negate( "${files[${f}][3]}", "${files[${f}][5]}" ),
         delete       => tidy;
}

body file_select name_age_negate(name,days)
{
leaf_name   => { "$(name)" };
mtime       => irange(0,ago(0,0,"$(days)",0,0,0));
file_result => "mtime.!leaf_name";
}

bundle agent efl_global_strings ( ref )
{
   meta:
      "purpose" string => "Set string type variable when class is true.";
      "field_0" string => "Context";
      "field_1" string => "Variable name";
      "field_2" string => "Variable value";
      "field_3" string => "Promisee";

   vars:
      "dim_string"
         comment => "Read data file for parsing.",
         handle  => "efl_global_strings_vars_files",
         int     => readstringarrayidx(
            "string_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

		"s"
			comment => "Get index array loaded above.",
			handle  => "efl_global_strings_vars_s",
			slist   => getindices( "string_o" );

      "s2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3" };

      "string[${s}][${s2}]"
         comment => "Work around for bug 2333",
         string => "${string_o[${s}][${s2}]}";

		"${string[${s}][1]}" -> { "${string[${s}][3]}" }
			comment    => "Define variable if class is true",
			ifvarclass => "${string[${s}][0]}",
			string     => "${string[${s}][2]}";
}

bundle agent efl_class_cmd_regcmp( ref )
{
   meta:
      "purpose" string => "Set global class if the given command output matches regex.";
      "wanring" string => "Commands in classes and variables are expensive";
      "field_0" string => "Context";
      "field_1" string => "Class promiser to set";
      "field_2" string => "Class expression is 'not' rather than 'expression'";
      "field_3" string => "command to run";
      "field_4" string => "useshell or noshell";
      "field_5" string => "anchored regex to match command output";
      "field_6" string => "Promisee";

   vars:
      "dim_class"
         comment => "Read data file for parsing.",
         handle  => "efl_class_cmd_regcmp_vars_files",
         int     => readstringarrayidx(
            "class_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

		"c"
			comment => "Get index array loaded above.",
			handle  => "efl_class_cmd_regcmp_vars_c",
			slist   => getindices( "class_o" );

      "c2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3", "4", "5", "6" };

      "class[${c}][${c2}]"
         comment => "Work around for bug 2333",
         string => "${class_o[${c}][${c2}]}";

		"cmd_output_${c}" -> { "${class[${c}][6]}" }
			comment    => "Capture commmand output",
			ifvarclass => "${class[${c}][0]}",
			string     => execresult( "${class[${c}][3]}", "${class[${c}][4]}" );

   classes:
      "${class[${c}][1]}_not" -> { "${class[${c}][6]}" }
         comment    => "Use not rather than expression",
         ifvarclass => "${class[${c}][0]}",
         expression => strcmp( "${class[${c}][2]}", "yes" );

      "${class[${c}][1]}_exp" -> { "${class[${c}][6]}" }
         comment    => "Use expression",
         ifvarclass => "${class[${c}][0]}",
         expression => strcmp( "${class[${c}][2]}", "no" );

      "${class[${c}][1]}" -> { "${class[${c}][6]}" }
         comment    => "Set class if command output matches the anchored regex.",
         scope      => "namespace",
         ifvarclass => "${class[${c}][1]}_exp",
         expression => regcmp( "${class[${c}][5]}", "${cmd_output_${c}}" );

      "${class[${c}][1]}" -> { "${class[${c}][6]}" }
         comment    => "Set class if command output matches the anchored regex.",
         scope      => "namespace",
         ifvarclass => "${class[${c}][1]}_not",
         not        => regcmp( "${class[${c}][5]}", "${cmd_output_${c}}" );
}

bundle agent efl_class_classmatch( ref )
{
   meta:
      "purpose" string => "Set global class if the given regex matches a defined class";
      "field_0" string => "Class promiser";
      "field_1" string => "Regex for the function classmatch";
      "field_2" string => "Promisee";

   vars:
      "dim_class"
         comment => "Read data file for parsing.",
         handle  => "efl_class_classmatch_vars_files",
         int     => readstringarrayidx(
            "class_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

		"c"
			comment => "Get index array loaded above.",
			handle  => "efl_class_classmatch_vars_c",
			slist   => getindices( "class_o" );

      "c2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2" };

      "class[${c}][${c2}]"
         comment => "Work around for bug 2333",
         string => "${class_o[${c}][${c2}]}";

   classes:
      "${class[${c}][0]}" -> { "${class[${c}][2]}" }
         comment    => "Set class if classmatch function returns true.",
         scope      => "namespace",
         expression => classmatch( "${class[${c}][1]}" );
}

bundle agent efl_class_iprange( ref )
{
   meta:
      "purpose" string => "Set global class if host IP is within the given range";
      "field_0" string => "Class promiser";
      "field_1" string => "IP address range in the format of the iprange function.";
      "field_2" string => "Promisee";

   vars:
      "dim_class"
         comment => "Read data file for parsing.",
         handle  => "efl_class_iprange_vars_files",
         int     => readstringarrayidx(
            "class_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

		"c"
			comment => "Get index array loaded above.",
			handle  => "efl_class_iprange_vars_c",
			slist   => getindices( "class_o" );

      "c2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2" };

      "class[${c}][${c2}]"
         comment => "Work around for bug 2333",
         string => "${class_o[${c}][${c2}]}";

   classes:
      "${class[${c}][0]}" -> { "${class[${c}][2]}" }
         comment    => "Set class if iprange function returns true.",
         scope      => "namespace",
         expression => iprange( "${class[${c}][1]}" );
}

bundle agent efl_class_hostname( ref )
#
# Reads parameter file in the form of <name>-<class>.txt.
# the file contains a list of unqualified hostnames separated by white space.
# If ${sys.uqhost} matches any name in the list <class> is defined.
{
   meta:
      "purpose" string => "Set global class if list item matches hostname";
      "field_0" string => "unqualified hostname";

   classes:
      "check_hostnames_${ref}"
         comment    => "Get class name from filename",
         expression => regextract( "${efl_c.class}", "${ref}", "class" );
      
      "${class[1]}"
         comment    => "Set class if unqualified hostname matches any list element.",
         scope      => "namespace",
         ifvarclass => canonify( "check_hostnames_${ref}" ),
         expression => regline( "${sys.uqhost}", "${ref}" );
}

bundle agent efl_copy_files ( ref )
{
   meta:
      "purpose" string => "Copy files";
      "field_0" string => "Context";
      "field_1" string => "File promiser";
      "field_2" string => "leaf regex";
      "field_3" string => "File source";
      "field_4" string => "Server";
      "field_5" string => "Encrypt transfer";
      "field_6" string => "file mode";
      "field_7" string => "file owner";
      "field_8" string => "file group";
      "field_9" string => "Promisee";

   vars:
      "dim_files"
         comment => "Read data file for parsing.",
         handle  => "efl_copy_files_vars_files",
         int     => readstringarrayidx(
            "files_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

		"f"
			comment => "Get index array loaded above.",
			handle  => "efl_copy_files_vars_f",
			slist   => getindices( "files_o" );

      "f2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" };

      "files[${f}][${f2}]"
         comment => "Work around for bug 2333",
         string => "${files_o[${f}][${f2}]}";

   classes:
      "recurse_${files[${f}][1]}_${f}"
         comment    => "Set if promiser is a directory",
         ifvarclass => "${files[${f}][0]}",
         expression => regcmp( ".+/\.", "${files[${f}][1]}" );
      
   files:
      "${files[${f}][1]}" -> { "${files[${f}][9]}" }
         comment    => "Create promiser directory",
         ifvarclass => canonify( "recurse_${files[${f}][1]}" ),
         create     => 'true';

      "${files[${f}][1]}" -> { "${files[${f}][9]}" }
         comment    => "Copy a single file",
         handle     => "efl_copy_files_remote_single",
         create     => 'true',
         classes    => efl_rkn( "${files[${f}][1]}", "efl_copy_files_remote_single" ),
         action     => efl_delta_reporting( "efl_copy_files_remote_single", "${files[${f}][1]}", "${files[${f}][9]}", "1" ),
         ifvarclass => and( "${files[${f}][0]}", not(  canonify( "recurse_${files[${f}][1]}" ) ) ),
         copy_from  => efl_cpf( "${files[${f}][3]}", "@{${files[${f}][4]}}", "${files[${f}][5]}" );

      "${files[${f}][1]}" -> { "${files[${f}][9]}" }
         comment      => "Copy and recurse",
         handle       => "efl_copy_files_remove_recurse",
         create       => 'true',
         classes      => efl_rkn( "${files[${f}][1]}", "efl_copy_files_remove_recurse" ),
         action       => efl_delta_reporting( "efl_copy_files_remove_recurse", "${files[${f}][1]}", "${files[${f}][9]}", "1" ),
         ifvarclass   => and( "${files[${f}][0]}", canonify( "recurse_${files[${f}][1]}_${f}" ) ),
         depth_search => recurse( "inf" ),
         file_select  => by_name( "${files[${f}][2]}" ),
         copy_from    => efl_cpf( "${files[${f}][3]}", "@{${files[${f}][4]}}", "${files[${f}][5]}" );

      "${files[${f}][1]}" -> { "${files[${f}][9]}" }
         comment    => "Promise permissions and ownership",
         handle     => "efl_copy_files_single_perms",
			classes    => efl_rkn( "${files[${f}][1]}", "efl_copy_files_single_perms" ),
			action     => efl_delta_reporting( "efl_copy_files_single_perms", "${files[${f}][1]}", "${files[${f}][9]}", "1" ),
         ifvarclass => and( "${files[${f}][0]}", not( canonify( "recurse_${files[${f}][1]}_${f}" ) ) ),
         perms      => mog( "${files[${f}][6]}", "${files[${f}][7]}", "${files[${f}][8]}" );

      "${files[${f}][1]}" -> { "${files[${f}][9]}" }
         comment      => "Promise permissions and ownership",
         handle       => "efl_copy_files_recurse_perms",
			classes      => efl_rkn( "${files[${f}][1]}", "efl_copy_files_recurse_perms" ),
			action       => efl_delta_reporting( "efl_copy_files_recurse_perms", "${files[${f}][1]}", "${files[${f}][9]}", "1" ),
         ifvarclass   => and( "${files[${f}][0]}", canonify( "recurse_${files[${f}][1]}_${f}" ) ),
         depth_search => recurse( "inf" ),
         file_select  => by_name( "${files[${f}][2]}" ),
         perms        => mog( "${files[${f}][6]}", "${files[${f}][7]}", "${files[${f}][8]}" );
}

body copy_from efl_cpf(from, server, encrypt)
{
   servers     => { "${server}" };
   source      => "${from}";
   encrypt     => "${encrypt}";
   compare     => "digest";
}

bundle agent efl_packages( ref )
{
   meta:
      "purpose" string => "Promises packages using generic method.";
      "field_0" string => "Context";
      "field_1" string => "Package policy";
      "field_2" string => "Package name regex";
      "field_3" string => "version string";
      "field_4" string => "arch, '*' seems to work to imply any arch";
      "field_5" string => "promisee";
      "ReadMe"  string => "Specify a version of '0' when version does not matter.";

   vars:
      "dim_pkg"
         comment => "Read data file for parsing.",
         handle  => "efl_packageg_vars_files",
         int     => readstringarrayidx(
            "pkg_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

		"p"
			comment => "Get index array loaded above.",
			handle  => "efl_packageg_vars_p",
			slist   => getindices( "pkg_o" );

      "p2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3", "4", "5" };

      "pkg[${p}][${p2}]"
         comment => "Work around for bug 2333",
         string => "${pkg_o[${p}][${p2}]}";

   classes:
      "do not specify version ${pkg[${p}][2]}_${pkg[${p}][3]}"
         comment    => "If version is '0' then do not specify version string",
         expression => strcmp( "${pkg[${p}][3]}", "0" );

   packages:
      "${pkg[${p}][2]}" -> { "${pkg[${p}][5]}" }
         comment               => "Promise package without version.",
         handle                => "efl_packageg_packages_generic_no_version",
			classes               => efl_rkn( "${pkg[${p}][2]}", "efl_packageg_packages_generic_no_version" ),
			action                => efl_delta_reporting( "efl_packageg_packages_generic_no_version", "${pkg[${p}][2]}", "${pkg[${p}][5]}", "1" ),
         ifvarclass            => and(
            canonify( "do not specify version ${pkg[${p}][2]}_${pkg[${p}][3]}" ),
            "${pkg[${p}][0]}"
         ),
         package_policy        => "${pkg[${p}][1]}",
         package_method        => generic,
         package_architectures => { "${pkg[${p}][4]}" };

      "${pkg[${p}][2]}" -> { "${pkg[${p}][5]}" }
         comment               => "Promise package with version.",
         handle                => "efl_packageg_packages_generic_version",
			classes               => efl_rkn( "${pkg[${p}][2]}", "efl_packageg_packages_generic_version" ),
			action                => efl_delta_reporting( "efl_packageg_packages_generic_version", "${pkg[${p}][2]}", "${pkg[${p}][5]}", "1" ),
         ifvarclass            => and(
            not( canonify( "do not specify version ${pkg[${p}][2]}_${pkg[${p}][3]}" ) ),
            "${pkg[${p}][0]}"
         ),
         package_policy        => "${pkg[${p}][1]}",
         package_method        => generic,
         package_version       => "${pkg[${p}][3]}",
         package_architectures => { "${pkg[${p}][4]}" };
}

bundle agent efl_start_service ( ref )
{
   meta:
      "purpose" string => "Start serivce with process and restart command.";
      "field_0" string => "Context";
      "field_1" string => "Process regex";
      "field_2" string => "Restart command";
      "field_3" string => "Promisee";

   vars:
      "dim_svc"
         comment => "Read data file for parsing.",
         handle  => "efl_start_service_vars_files",
         int     => readstringarrayidx(
            "svc_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

		"s"
			comment => "Get index array loaded above.",
			handle  => "efl_start_service_vars_s",
			slist   => getindices( "svc_o" );

      "s2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3" };

      "svc[${s}][${s2}]"
         comment => "Work around for bug 2333",
         string => "${svc_o[${s}][${s2}]}";

   processes:
      "${svc[${s}][1]}" -> { "${svc[${s}][3]}" }
         comment       => "Promise process is running",
         handle        => "efl_start_service_processes_proc",
			classes       => efl_rkn( "${svc[${c}][1]}", "efl_start_service_processes_proc" ),
			action        => efl_delta_reporting( "efl_start_service_processes_proc", "${svc[${c}][1]}", "${svc[${c}][3]}", "1" ),
         ifvarclass    => "${svc[${s}][0]}",
         restart_class => canonify( "efl_start_service_command_${svc[${s}][1]}" );

   commands:
      "${svc[${s}][2]}" -> { "${svc[${s}][3]}" }
         comment    => "Restart service is required.",
         handle     => "efl_start_service_commands_restart",
			classes    => efl_rkn( "${svc[${c}][1]}", "efl_start_service_commands_restart" ),
			action     => efl_delta_reporting( "efl_start_service_commands_restart", "${svc[${c}][1]}", "${svc[${c}][3]}", "1" ),
         contain    => in_shell_and_silent,
         ifvarclass => canonify( "efl_start_service_command_${svc[${s}][1]}" );
}

bundle agent efl_service ( ref )
{
   meta:
      "purpose" string => "Promise serivce with file, process, and restart command.";
      "field_0" string => "Context";
      "field_1" string => "Process regex";
      "field_2" string => "Configuration file promiser";
      "field_3" string => "Configuration file source";
      "field_4" string => "Template file yes/no";
      "field_5" string => "Encrypted copy yes/now";
      "field_6" string => "Configuration file mode";
      "field_7" string => "Configuration file owner";
      "field_8" string => "Configuration file group";
      "field_9" string => "Restart command";
      "field_10" string => "Promisee";

   vars:
      "dim_svc"
         comment => "Read data file for parsing.",
         handle  => "efl_service_vars_files",
         int     => readstringarrayidx(
            "svc_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

		"s"
			comment => "Get index array loaded above.",
			handle  => "efl_service_vars_s",
			slist   => getindices( "svc_o" );

      "s2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" };

      "svc[${s}][${s2}]"
         comment => "Work around for bug 2333",
         string => "${svc_o[${s}][${s2}]}";

   classes:
      "${svc[${s}][3]}_is_not_a_template" 
         comment    => "Is configuration file a template?",
         ifvarclass => "${svc[${s}][0]}",
         expression => strcmp( "${svc[${s}][4]}", "no" );

      "${svc[${s}][3]}_is_a_template"
         comment    => "Is configuration file a template?",
         ifvarclass => "${svc[${s}][0]}",
         expression => strcmp( "${svc[${s}][4]}", "yes" );

   files:
      "${efl_c.cache}/${svc[${s}][2]}" -> { "${svc[${s}][10]}" }
         comment    => "Cache the source file source file",
         handle     => "efl_service_files_cache",
			classes    => efl_rkn( "${efl_c.cache}/${svc[${s}][2]}", "efl_service_svc_cache" ),
			action     => efl_delta_reporting( "efl_service_svc_cache", "${efl_c.cache}/${svc[${s}][2]}", "${svc[${s}][10]}", "1" ),
         ifvarclass => "${svc[${s}][0]}",
         create     => "true",
         perms      => mog(
            "${svc[${s}][6]}",
            "${svc[${s}][7]}",
            "${svc[${s}][8]}"   
            ),
         copy_from  => efl_cpf( "${svc[${s}][3]}", "@{efl_c.policy_servers}", "${svc[${s}][5]}" );

      "${svc[${s}][2]}" -> { "${svc[${s}][10]}" }
         comment    => "Promise contents of configuration file",
         handle     => "efl_service_files_config",
			classes    => efl_rkn( "${svc[${s}][2]}", "efl_service_files_config" ),
			action     => efl_delta_reporting( "efl_service_files_config", "${svc[${s}][2]}", "${svc[${s}][10]}", "1" ),
         ifvarclass => canonify( "${svc[${s}][3]}_is_not_a_template" ),
         create     => "true",
         copy_from  => efl_cpf( "${efl_c.cache}/${svc[${s}][2]}", "localhost", "${svc[${s}][5]}" );

      "${svc[${s}][2]}" -> { "${svc[${s}][10]}" }
         comment       => "Promise contents of configurationn file from template",
         handle        => "efl_service_files_config_template",
			classes       => efl_rkn( "${svc[${s}][2]}", "efl_service_files_config_template" ),
			action        => efl_delta_reporting( "efl_service_files_config_template", "${svc[${s}][2]}", "${svc[${s}][10]}", "1" ),
         create        => "true",
         edit_defaults => empty,
         ifvarclass    => canonify( "${svc[${s}][3]}_is_a_template" ),
         edit_template => "${efl_c.cache}/${svc[${s}][2]}";

      "${svc[${s}][2]}" -> { "${svc[${s}][10]}" }
         comment    => "Promise permissions of configuration file",
         handle     => "efl_service_files_config_template_permissions",
			classes    => efl_rkn( "${svc[${s}][2]}", "efl_service_files_config_template_permissions" ),
			action     => efl_delta_reporting( "efl_service_files_config_template_permissions", "${svc[${s}][2]}", "${svc[${s}][10]}", "1" ),
         ifvarclass => "${svc[${s}][0]}",
         perms      => mog(
            "${svc[${s}][6]}",
            "${svc[${s}][7]}",
            "${svc[${s}][8]}"   
            );

   processes:
      "${svc[${s}][1]}" -> { "${svc[${s}][10]}" }
         comment        => "Promise process is running",
         handle         => "efl_service_processes_proc",
			classes        => efl_rkn( "${svc[${s}][1]}", "efl_service_processes_proc" ),
			action         => efl_delta_reporting( "efl_service_processes_proc", "${svc[${s}][1]}", "${svc[${s}][10]}", "1" ),
			process_select => by_command( "${svc[${s}][1]}" ),
         ifvarclass     => "${svc[${s}][0]}",
         restart_class  => canonify( "efl_service_command_${svc[${s}][9]}" );

   commands:
      "${svc[${s}][9]}" -> { "${svc[${s}][10]}" }
         comment    => "Restart service is required.",
         handle     => "efl_service_commands_restart",
			classes    => efl_rkn( "${svc[${s}][9]}", "efl_service_commands_restart" ),
			action     => efl_delta_reporting( "efl_service_commands_restart", "${svc[${s}][9]}", "${svc[${s}][10]}", "1" ),
         contain    => in_shell_and_silent,
         ifvarclass => or (
				canonify( "efl_service_command_${svc[${s}][9]}" ),
				canonify( "${svc[${s}][2]}_handle_efl_service_files_config_repaired" ),
				canonify( "${svc[${s}][2]}_handle_efl_service_files_config_template_repaired" )
				);
}

body process_select by_command( command )
{
	command        => "${command}";
	process_result => "command";
}

bundle agent efl_chkconfig_enable_service ( ref )
{
   meta:
      "purpose" string => "Enable service boot using chkconfig.";
      "field_0" string => "Context";
      "field_1" string => "Service name promiser";
      "field_2" string => "Promisee";

   vars:
      debian::
         "chkconfig_check"
            comment => "Check mode required for Debian's chkconfig",
            string  => "${paths.path[chkconfig]} -c";

      !debian::
         "chkconfig_check"
            comment => "Check mode not required for none Debian",
            string  => "${paths.path[chkconfig]}";

      any::
         "dim_svc"
            comment => "Read data file for parsing.",
            handle  => "efl_chkconfig_enable_service_vars_files",
            int     => readstringarrayidx(
               "svc_o",
               "${ref}",
               "${efl_c.comment}",
               "${efl_c.array_delimiter}",
               "${efl_c.max_num}",
               "${efl_c.max_bytes}"
            );

		"s"
			comment => "Get index array loaded above.",
			handle  => "efl_chkconfig_enable_service_vars_s",
			slist   => getindices( "svc_o" );

      "s2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2" };

      "svc[${s}][${s2}]"
         comment => "Work around for bug 2333",
         string => "${svc_o[${s}][${s2}]}";

   classes:
      _stdlib_path_exists_chkconfig::
         "efl_chkconfig_enable_${svc[${s}][1]}"
            comment    => "Check if service is enabled",
				handle     => "efl_chkconfig_enable_classes_needs_repair",
            ifvarclass => "${svc[${s}][0]}",
            not        => returnszero( "${chkconfig_check} ${svc[${s}][1]}", "noshell" );

         "${svc[${s}][1]}_handle_efl_chkconfig_enable_classes_ok_kept"
            comment    => "Check if service is enabled",
				handle     => "efl_chkconfig_enable_classes_ok",
				scope      => "namespace",
            ifvarclass => "${svc[${s}][0]}",
            expression => returnszero( "${chkconfig_check} ${svc[${s}][1]}", "noshell" );

   commands:
      "${paths.path[chkconfig]} ${svc[${s}][1]} on" -> { "${svc[${s}][2]}" }
         comment    => "Enable service using chkconfig",
         handle     => "efl_chkconfig_enable_service_commands_chkconfig",
         ifvarclass => canonify( "efl_chkconfig_enable_${svc[${s}][1]}" ),
			classes    => efl_rkn( "${paths.path[chkconfig]} ${svc[${s}][1]} off", "efl_chkconfig_enable_service_commands_chkconfig" ),
			action     => efl_delta_reporting( "efl_chkconfig_enable_service_commands_chkconfig", "${svc[${s}][1]}", "${svc[${s}][2]}", "1" ),
         contain    => silent;

   reports:
      delta_reporting::
         "${efl_c.udate} ;; efl_chkconfig_enable_classes_ok ;; ${svc[${s}][1]} ;; ${svc[${s}][2]}"
            ifvarclass      => canonify( "${svc[${s}][1]}_handle_efl_chkconfig_enable_classes_ok_kept" ),
            report_to_file  => "${efl_c.promise_log}";

      !_stdlib_path_exists_chkconfig::
         "Promise ${this.handle} reports ${paths.path[chkconfig]} is not found."
            handle => "efl_chkconfig_enable_service_reports_no_chkconfig";

}

bundle agent efl_chkconfig_disable_service ( ref )
{
   meta:
      "purpose" string => "Disable service boot using chkconfig.";
      "field_0" string => "Context";
      "field_1" string => "Service name promiser";
      "field_2" string => "Promisee";

   vars:
      debian::
         "chkconfig_check"
            comment => "Check mode required for Debian's chkconfig",
            string  => "${paths.path[chkconfig]} -c";

      !debian::
         "chkconfig_check"
            comment => "Check mode not required for none Debian",
            string  => "${paths.path[chkconfig]}";

      any::
         "dim_svc"
            comment => "Read data file for parsing.",
            handle  => "efl_chkconfig_disable_service_vars_files",
            int     => readstringarrayidx(
               "svc_o",
               "${ref}",
               "${efl_c.comment}",
               "${efl_c.array_delimiter}",
               "${efl_c.max_num}",
               "${efl_c.max_bytes}"
            );

		"s"
			comment => "Get index array loaded above.",
			handle  => "efl_chkconfig_disable_service_vars_s",
			slist   => getindices( "svc_o" );

      "s2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2" };

      "svc[${s}][${s2}]"
         comment => "Work around for bug 2333",
         string => "${svc_o[${s}][${s2}]}";

   classes:
      _stdlib_path_exists_chkconfig::
         "efl_chkconfig_disable_${svc[${s}][1]}"
            comment    => "Check if service is enabled",
				handle     => "efl_chkconfig_disable_classes_needs_repair",
            ifvarclass => "${svc[${s}][0]}",
            expression => returnszero( "${chkconfig_check} ${svc[${s}][1]}", "noshell" );

         "${svc[${s}][1]}_handle_efl_chkconfig_disable_classes_ok_kept"
            comment    => "Check if service is enabled",
				handle     => "efl_chkconfig_disable_classes_ok",
				scope      => "namespace",
            ifvarclass => "${svc[${s}][0]}",
            not        => returnszero( "${chkconfig_check} ${svc[${s}][1]}", "noshell" );

   commands:
      "${paths.path[chkconfig]} ${svc[${s}][1]} off" -> { "${svc[${s}][2]}" }
         comment    => "Enable service using chkconfig",
         handle     => "efl_chkconfig_disable_service_commands_chkconfig",
         ifvarclass => canonify( "efl_chkconfig_disable_${svc[${s}][1]}" ),
			classes    => efl_rkn( "${paths.path[chkconfig]} ${svc[${s}][1]} off", "efl_chkconfig_disable_service_commands_chkconfig" ),
			action     => efl_delta_reporting( "efl_chkconfig_disable_service_commands_chkconfig", "${svc[${s}][1]}", "${svc[${s}][2]}", "1" ),
         contain    => silent;

   reports:
      delta_reporting::
         "${efl_c.udate} ;; efl_chkconfig_disable_classes_ok ;; ${svc[${s}][1]} ;; ${svc[${s}][2]}"
            ifvarclass      => canonify( "${svc[${s}][1]}_handle_efl_chkconfig_disable_classes_ok_kept" ),
            report_to_file  => "${efl_c.promise_log}";

      !_stdlib_path_exists_chkconfig::
         "Promise ${this.handle} reports ${paths.path[chkconfig]} is not found."
            handle => "efl_chkconfig_disable_service_reports_no_chkconfig";
}

bundle agent efl_file_perms ( ref )
{
   meta:
      "purpose" string => "Promise file permissions.";
      "field_0" string => "Context";
      "field_1" string => "Promiser file";
      "field_2" string => "Recurse into promiser directory no/#/inf)";
      "field_3" string => "Leaf regex";
      "field_4" string => "Negative match?";
      "field_5" string => "Promiser mode";
      "field_6" string => "Promiser owner";
      "field_7" string => "Promiser group";
      "field_8" string => "Promisee";

   vars:
      "dim_files"
         comment => "Read data file for parsing.",
         handle  => "efl_file_perms_vars_files",
         int     => readstringarrayidx(
            "files_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

		"f"
			comment => "Get index array loaded above.",
			handle  => "efl_file_perms_vars_f",
			slist   => getindices( "files_o" );

      "f2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3", "4", "5", "6", "7", "8" };

      "files[${f}][${f2}]"
         comment => "Work around for bug 2333",
         string => "${files_o[${f}][${f2}]}";

      classes:
         "efl_no_recurse_${files[${f}][1]}"
            comment    => "Is recursion desired?",
            handle     => "efl_files_perms_classes_recurse",
            ifvarclass => "${files[${f}][0]}",
            expression => strcmp( "no", "${files[${f}][2]}" );
         
         "efl_negative_match_${files[${f}][1]}"
            comment => "Is negative match desired?",
            handle => "efl_files_perms_classes_negate",
            ifvarclass => "${files[${f}][0]}",
            expression => strcmp( "yes", "${files[${f}][4]}" );

         "efl_positive_match_${files[${f}][1]}"
            comment => "Is positive match desired?",
            handle => "efl_files_perms_classes_positive",
            ifvarclass => "${files[${f}][0]}",
            expression => strcmp( "no", "${files[${f}][4]}" );

      files:
         "${files[${f}][1]}" -> { "${files[${f}][8]}" }
            comment      => "Promise permissions of file recurse_with_base and positive match",
            handle       => "efl_files_perms_files_recurse_with_base_postive",
            ifvarclass   => and(
               not( canonify( "efl_no_recurse_${files[${f}][1]}" ) ),
               canonify( "efl_positive_match_${files[${f}][1]}")
               ),
				classes      => efl_rkn( "${files[${f}][1]}", "efl_files_perms_files_recurse_with_base_postive" ),
				action       => efl_delta_reporting( "efl_files_perms_files_recurse_with_base_postive", "${files[${f}][1]}", "${files[${f}][8]}", "1" ),
            depth_search => recurse_with_base( "${files[${f}][2]}" ),
            file_select  => by_name( "${files[${f}][3]}" ),
            perms        => mog( "${files[${f}][5]}", "${files[${f}][6]}", "${files[${f}][7]}" );

         "${files[${f}][1]}" -> { "${files[${f}][8]}" }
            comment      => "Promise permissions of file recurse_with_base and negative leaf match",
            handle       => "efl_files_perms_files_recurse_with_base_negative",
            ifvarclass   => and(
               not( canonify( "efl_no_recurse_${files[${f}][1]}" ) ),
               canonify( "efl_negative_match_${files[${f}][1]}")
               ),
				classes      => efl_rkn( "${files[${f}][1]}", "efl_files_perms_files_recurse_with_base_negative" ),
				action       => efl_delta_reporting( "efl_files_perms_files_recurse_with_base_negative", "${files[${f}][1]}", "${files[${f}][8]}", "1" ),
            depth_search => recurse_with_base( "${files[${f}][2]}" ),
            file_select  => negate_by_name( "${files[${f}][3]}" ),
            perms        => mog( "${files[${f}][5]}", "${files[${f}][6]}", "${files[${f}][7]}" );

         "${files[${f}][1]}" -> { "${files[${f}][8]}" }
            comment      => "Promise permissions using positive match",
            handle       => "efl_files_perms_files_positive",
            ifvarclass   => and(
               canonify( "efl_no_recurse_${files[${f}][1]}" ),
               canonify( "efl_positive_match_${files[${f}][1]}")
               ),
				classes      => efl_rkn( "${files[${f}][1]}", "efl_files_perms_files_positive" ),
				action       => efl_delta_reporting( "efl_files_perms_files_positive", "${files[${f}][1]}", "${files[${f}][8]}", "1" ),
            file_select  => by_name( "${files[${f}][3]}" ),
            perms        => mog( "${files[${f}][5]}", "${files[${f}][6]}", "${files[${f}][7]}" );

         "${files[${f}][1]}" -> { "${files[${f}][8]}" }
            comment      => "Promise permissions using negative leaf match",
            handle       => "efl_files_perms_files_negative",
            ifvarclass   => and(
               canonify( "efl_no_recurse_${files[${f}][1]}" ),
               canonify( "efl_negative_match_${files[${f}][1]}")
               ),
				classes      => efl_rkn( "${files[${f}][1]}", "efl_files_perms_files_negative" ),
				action       => efl_delta_reporting( "efl_files_perms_files_negative", "${files[${f}][1]}", "${files[${f}][8]}", "1" ),
            file_select  => negate_by_name( "${files[${f}][3]}" ),
            perms        => mog( "${files[${f}][5]}", "${files[${f}][6]}", "${files[${f}][7]}" );
}

body file_select negate_by_name(names)
{
   leaf_name  => { @(names)};
   file_result => "!leaf_name";
}

bundle agent efl_edit_template ( ref )
{
   meta:
      "purpose" string => "Promise whole contents of files";
      "field_0" string => "Class or context";
      "field_1" string => "Promiser file";
      "field_2" string => "Source file";
      "field_3" string => "Mode";
      "field_4" string => "Owner";
      "field_5" string => "Group";
      "field_6" string => "Promisee";

   vars:
      "dim_files"
         comment => "Read data file for parsing.",
         handle  => "efl_edit_template_vars_files",
         int     => readstringarrayidx(
            "files_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

		"f"
			comment => "Get index array loaded above.",
			handle  => "efl_edit_template_vars_f",
			slist   => getindices( "files_o" );

      "f2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3", "4", "5", "6", "7", "8" };

      "files[${f}][${f2}]"
         comment => "Work around for bug 2333",
         string => "${files_o[${f}][${f2}]}";

   files:
      "${efl_c.cache}/${files[${f}][1]}" -> { "${files[${f}][6]}" }
         comment    => "Locally cache template file.",
         handle     => "efl_edit_template_cache_template",
			classes    => efl_rkn( "${efl_c.cache}/${files[${f}][1]}", "efl_edit_template_cache_template" ),
			action     => efl_delta_reporting( "efl_edit_template_cache_template", "${efl_c.cache}/${files[${f}][1]}", "${files[${f}][6]}", "1" ),
         ifvarclass => "${files[${f}][0]}",
         create     => "true",
         perms      => mog( "${files[${f}][3]}", "${files[${f}][4]}", "${files[${f}][5]}" ),
         copy_from  => remote_dcp( "${files[${f}][2]}", "@{efl_c.policy_servers}" );

      "${files[${f}][1]}" -> { "${files[${f}][6]}" }
         comment       => "Promise contents of file",
         handle        => "efl_edit_template_files_promiser",
			classes    => efl_rkn( "${files[${f}][1]}", "efl_edit_template_files_promiser" ),
			action     => efl_delta_reporting( "efl_edit_template_files_promiser", "${files[${f}][1]}", "${files[${f}][6]}", "1" ),
         ifvarclass    => "${files[${f}][0]}",
         create        => "true",
         edit_defaults => empty,
         edit_template => "${efl_c.cache}/${files[${f}][1]}";

      "${files[${f}][1]}" -> { "${files[${f}][6]}" }
         comment    => "Promise permissions of file",
         handle     => "efl_edit_template_files_perms",
			classes    => efl_rkn( "${files[${f}][1]}", "efl_edit_template_files_perms" ),
			action     => efl_delta_reporting( "efl_edit_template_files_perms", "${files[${f}][1]}", "${files[${f}][6]}", "1" ),
         ifvarclass => "${files[${f}][0]}",
         perms      => mog( "${files[${f}][3]}", "${files[${f}][4]}", "${files[${f}][5]}" );
}

bundle agent efl_lastseen
{
   meta:
      'purpose' string => "Report agents that have checked in, in the past 24 hours";

   vars:
      'hours'
         comment => "Last seen horizon in hours",
         int     => '24';

      'last_seen_hosts'
         comment => "Make list of addresses seen within the given hours",
         slist   => hostsseen( "${hours}", "lastseen", "address" );

   reports:
      cfengine::
         "${last_seen_hosts}"
            handle => "efl_lastseen_reports_hosts";
}

bundle agent efl_notseen
{
   meta:
      'purpose' string => "Report agents that have not checked in, in the past 24 hours";

   vars:
      'hours'
         comment => "Not seen within the last x hours",
         int     => '24';

      'last_seen_hosts'
         comment => "Make list of addresses not seen within the given hours",
         slist   => hostsseen( "${hours}", "notseen", "address" );

   reports:
      cfengine::
         "${last_seen_hosts}"
            handle => "efl_notseen_reports_hosts";
}

bundle agent efl_mon_cfengine
{
    meta:
        "purpose" string => "Report Cfengine connections stats from cf-monitord";

    reports:
        cfengine::
           "Current inbound connections: ${mon.value_cfengine_in}";
           "Average number of inbound connections per 5min: ${mon.av_cfengine_in}";
           "Standard deviation: ${mon.dev_cfengine_in}";
           "Current outbound connections: ${mon.value_cfengine_out}";
           "Average number of outbound connections per 5min: ${mon.av_cfengine_out}";
           "Standard deviation: ${mon.dev_cfengine_out}";
}

bundle server efl_server
{
   meta:
      "purpose" string => "Read cf-server access rules.";
      "field_0" string => "Context";
      "field_1" string => "Promiser directory";
      "field_2" string => "Comma separated admit list";
      "field_3" string => "Promisee";

   vars:
      "dim_acl"
         comment => "Read data file for parsing.",
         handle  => "efl_server_vars_files",
         int     => readstringarrayidx(
            "acl_o",
            "${efl_c.efl_server_txt}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

		"f"
			comment => "Get index array loaded above.",
			handle  => "efl_server_vars_f",
			slist   => getindices( "acl_o" );

      "f2"
         comment => "Work around for bug 2333",
         slist   => { "0","1","2","3" };
 
      "acl[${f}][${f2}]"
         comment => "Work around for bug 2333",
         string  => "${acl_o[${f}][${f2}]}";

      "acl_list[${f}]"
         comment => "Turn comma list into slist",
         slist   => splitstring( "${acl[${f}][2]}", "\s*,\s*", "10" );

   access:

      "${acl[${f}][1]}" -> { "${acl[${f}][3]}" }
            handle     => "efl_server_grant_access_policy",
            comment    => "Grant client access to the policy server",
            ifvarclass => "${acl[${f}][0]}",
            admit      => { "@{acl_list[${f}]}" };
}

body action efl_delta_reporting ( handle, promiser, promisee, if_elapsed )
{
   ifelapsed => "${if_elapsed}";

   upassive::
      action_policy => 'warn';

   delta_reporting::
      log_kept     => "${efl_c.promise_log}";
      log_repaired => "${efl_c.promise_log}";
      log_failed   => "${efl_c.promise_log}";
		log_string   => "${handle} ;; ${promiser} ;; ${promisee}";
# Remove date due to CFEngine bug 3441
		#log_string   => "${efl_c.udate} ;; ${handle} ;; ${promiser} ;; ${promisee}";
}

body classes efl_rkn( promiser, handle )
{
      promise_kept      => { "${promiser}_handle_${handle}_kept" };
      promise_repaired  => { "${promiser}_handle_${handle}_repaired" };
      repair_failed     => { "${promiser}_handle_${handle}_notkept" };
      repair_denied     => { "${promiser}_handle_${handle}_notkept" };
      repair_timeout    => { "${promiser}_handle_${handle}_notkept" };
}

bundle agent efl_bug3430 (ref)
{
	meta:
		"purpose" string => "Workaround CFEngine tcdb corruption and deadlock issues";
		"readme"  string => "See bug https://cfengine.com/dev/issues/3430";

	vars:
      redhat::
         "lsof" string => "/usr/sbin/lsof";

      debian::
         "lsof" string => "/usr/bin/lsof";

      any::
		"cf_lock_tcdb"
			comment => "Location of lock database",
			string  => "${sys.workdir}/state/cf_lock.tcdb";

		"cf_lock_tcdb_lock"
			comment => "Location of lock database",
			string  => "${cf_lock_tcdb}.lock";

		"lsof_pids_string"
			comment => "Count number of openings to cf_lock.tcdb",
			string  => execresult( "${lsof} -t ${cf_lock_tcdb_lock}", "noshell" );

		"lsof_pids"
			comment => "Convert string to list",
			slist   => splitstring( "${lsof_pids_string}", "\s+", "10" );

		"no_of_pids"
			comment => "Convert string returned from execresult to int",
			int     => length( "lsof_pids" );

	classes:
		"kill_pids"
			expression => isgreaterthan( "${no_of_pids}", "1" );

		"delete_cf_lock"
			expression => "efl_bug3430_processes_kill_cf_agent_repaired";

		"report_kill_and_delete"
			expression => classmatch( "efl_bug3430.*?_repaired" );

	files:
		delete_cf_lock::
			"${cf_lock_tcdb}" -> { "CFEngine bug 3430" }
				comment => "Remove corrupted lock file",
				handle  => "efl_bug3430_files_delete_cf_lock_tcdb",
				classes => efl_rkn( "${cf_lock_tcdb}", "efl_bug3430_files_delete_cf_lock_tcdb" ),
				action  => efl_delta_reporting( "efl_bug3430_files_delete_cf_lock_tcdb", "${cf_lock_tcdb}", "CFEngine bug 3430", "1" ),
				delete  => tidy;

	processes:
		kill_pids::
			"cf-agent" -> { "CFEngine bug 3430" }
				comment        => "Kill pids",
				handle         => "efl_bug3430_processes_kill_cf_agent",
				signals        => { "term", "kill" },
				classes        => efl_rkn( "cf-agent", "efl_bug3430_processes_kill_cf_agent" ),
				action         => efl_delta_reporting( "efl_bug3430_processes_kill_cf_agent", "cf-agent", "CFEngine bug 3430", "1" ),
				process_select => by_pid( "${lsof_pids}" );

	reports:
		report_kill_and_delete::
			"TCDB corruption detected. Repair was attempted.";
}

body process_select by_pid( pid )
{
	pid            => irange( "${pid}", "${pid}" );
	process_result => "pid";
}

